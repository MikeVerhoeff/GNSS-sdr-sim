library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity DopplerUpsample is
  generic(
    radioFrequencyOut : integer := 1575420000;
    radioFrequencyIn  : integer := 1575420000;
    inputRate         : integer := 511000;
    outputRate        : integer := 20000000;
    subCycles         : integer := 1
  ); 
  port (
    reset      : in std_logic;
    
    clk_output : in  std_logic;
    I_output   : out integer;
    Q_output   : out integer;

    clk_input  : out std_logic;
    I_input    : in integer;
    Q_input    : in integer;

    doppler_shift : in integer;
    delay         : in integer
  );
end DopplerUpsample;

architecture arch1 of DopplerUpsample is

  constant MAX_INT : integer := 2147483647;

  signal n : integer;
  signal itterNStep : integer;
  signal bufferNStep : integer;

  signal unitPhase : integer;
  signal unitPhaseStep : integer;

  signal lastDelay : integer;
  signal lastDoppler : integer;

begin

  process( clk_output, reset, doppler_shift, delay )
    variable next_n : integer;
  begin
    next_n := n;
    report "initalized n " & integer'image(next_n);
    if reset = '1' then
      itterNStep <= subCycles * inputRate;
      bufferNStep <= subCycles * outputRate;
      next_n := 0;
      unitPhase <= 0;
      unitPhaseStep <= ((radioFrequencyIn + doppler_shift - radioFrequencyOut) / outputRate) * (MAX_INT / 2);
      lastDelay <= delay;
      next_n := next_n-delay;
      clk_input <= '0';
      
      report "reset " & integer'image(next_n) & " - " & integer'image(delay);
      
    elsif rising_edge( clk_output ) then
      I_output <= I_input;
      Q_output <= Q_input; -- todo: add phase

      next_n := next_n + itterNStep;
      unitPhase <= unitPhase+unitPhaseStep;
      if (next_n >= bufferNStep) then
        clk_input <= '1';
        next_n := next_n - bufferNStep;
      end if;

    elsif falling_edge( clk_output ) then
      clk_input <= '0';
    
    elsif lastDelay /= delay then
      next_n := next_n + lastDelay - delay;
      lastDelay <= delay;
    
    elsif lastDoppler /= doppler_shift then
      unitPhaseStep <= ((radioFrequencyIn + doppler_shift - radioFrequencyOut) / outputRate) * (MAX_INT / 2);
    
    end if;
    report "update n " & integer'image(next_n);
    n <= next_n;
  end process;

end arch1;